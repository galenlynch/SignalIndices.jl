var documenterSearchIndex = {"docs":
[{"location":"guide/#guide","page":"Usage Guide","title":"Usage Guide","text":"Functions are grouped by category. Each entry links to the full docstring in the API Reference.","category":"section"},{"location":"guide/#Index/Time-Conversion","page":"Usage Guide","title":"Index/Time Conversion","text":"Convert between 1-based sample indices and time values for regularly sampled data.\n\nndx_to_t converts an index (or array of indices) to time:\n\nfs = 30_000.0\nndx_to_t(15001, fs)        # 0.5\nndx_to_t(15001, fs, 1.0)   # 1.5 (with start_t offset)\n\nt_to_ndx converts a time to the first sample index at or after that time. t_to_last_ndx returns the last sample at or before the time. t_sup_to_ndx returns the last sample strictly before the time.\n\nt_to_ndx(0.5, fs)           # 15001\nt_to_last_ndx(0.5, fs)      # 15001\nt_sup_to_ndx(0.5, fs)       # 15000\n\nn_ndx counts the number of indices in a range. ndx_offset computes the end index for a given start and number of points. ndx_wrap wraps an index using modular arithmetic.\n\nclip_ndx clamps an index to 1:length. clip_ndx_deviance also returns how far the index was clipped.\n\nclip_ndx(0, 100)              # 1\nclip_ndx(150, 100)            # 100\nclip_ndx_deviance(150, 100)   # (100, -50)\n\nduration and time_interval compute timing information for a signal:\n\nduration(30001, fs)            # 1.0 (seconds)\ntime_interval(30001, fs, 0.0)  # (0.0, 1.0)","category":"section"},{"location":"guide/#Bin-and-Window-Operations","page":"Usage Guide","title":"Bin and Window Operations","text":"bin_bounds returns the (start, stop) indices for a bin number and bin size. bin_center returns the center index.\n\nbin_bounds(2, 10)     # (11, 20)\nbin_center(2, 10)     # 15.5\n\nexpand_selection widens an index range by a given amount, clamped to [1, imax]:\n\nexpand_selection(5, 10, 100, 3)  # (2, 13)\n\nmake_slice_idx and make_expand_idx construct index tuples for programmatic slicing and broadcasting along arbitrary dimensions.\n\nview_trailing_slice returns a view sliced along the last dimension:\n\nA = rand(3, 4, 5)\nv = view_trailing_slice(A, 2)  # equivalent to view(A, :, :, 2)","category":"section"},{"location":"guide/#Signal-Processing","page":"Usage Guide","title":"Signal Processing","text":"moving_sum / moving_sum! compute a sliding window sum without zero-padding:\n\nmoving_sum([1, 2, 3, 4, 5], 3)  # [6, 9, 12]\n\nlocal_extrema finds indices of local maxima (default) or minima:\n\nlocal_extrema([1, 3, 2, 4, 1])        # [2] (local max at index 2)\nlocal_extrema([1, 3, 2, 4, 1], <)     # [3] (local min at index 3)\n\nfind_local_extrema hill-climbs from a starting index to the nearest extremum.\n\nfind_all_edge_triggers / find_first_edge_trigger detect threshold crossings (rising edges):\n\nfind_all_edge_triggers([0, 0, 1, 1, 0, 1], 1)  # [3, 6]\nfind_first_edge_trigger([0, 0, 1, 1, 0, 1], 1)  # 3\n\nthresh_cross finds where a signal crosses upward through a threshold. indices_above_thresh returns contiguous ranges where the signal exceeds a threshold.\n\nfilter_no_collisions removes elements from one sorted array that are within a collision radius of elements in another:\n\nfilter_no_collisions([1, 5, 10, 15], [4, 14], 2)  # [1, 10]\n\nwindow_counts counts the number of events within a sliding time window.\n\nuniformhist / uniformhist! compute fast histograms for regularly-spaced bins, using reciprocal multiplication for speed:\n\nuniformhist([0.1, 0.5, 1.2, 2.9], 0.0:1.0:3.0)  # [2, 1, 1]\n\ncentered_basis returns a range of points centered around zero. stepsize extracts the step size from a range or regularly sampled vector.","category":"section"},{"location":"guide/#Array-Utilities","page":"Usage Guide","title":"Array Utilities","text":"weighted_mean and weighted_mean_dim compute weighted averages:\n\nweighted_mean([1.0, 2.0, 3.0], [0.5, 0.3, 0.2])  # 1.7\n\nsimple_summary_stats returns (mean, std, sem) in one call.\n\nfind_closest returns the index of the nearest value:\n\nfind_closest([1.0, 3.0, 5.0], 2.8)  # 2\n\nfind_subseq finds all starting indices where a subsequence occurs.\n\nsubselect extracts sub-vectors using (start, stop) index tuples.\n\nrev_view returns a reversed view without copying.\n\ntrailing_zeros_idx finds the last non-zero index.\n\nclipsize! resizes a vector and releases excess memory.\n\ncopy_length_check and copy_length_dest_check validate that a destination has room for a copy operation.\n\ninvert_perm returns the inverse of a permutation vector.","category":"section"},{"location":"guide/#Pairwise-Operations","page":"Usage Guide","title":"Pairwise Operations","text":"pairwise_idxs generates all unique (i, j) pairs where i > j:\n\npairwise_idxs(3)  # [(2,1), (3,1), (3,2)]\n\npairwise_idx converts a pair back to its linear index.\n\nmap_pairwise applies a function to all unique pairs from a vector:\n\nmap_pairwise(-, [10, 20, 30])  # [10, 20, 10]\n\nimap_product lazily maps a function over the Cartesian product of two collections.","category":"section"},{"location":"guide/#Filtering-and-Comparison","page":"Usage Guide","title":"Filtering and Comparison","text":"filtermap combines filter and map in a single pass.\n\nfind_not_unique returns indices of all duplicate elements.\n\nskipoftype / skipnothing return iterators that skip elements of a given type:\n\nsum(skipnothing([1, nothing, 2, nothing, 3]))  # 6\n\nallsame checks whether all elements (or mapped values) are equal:\n\nallsame([1, 1, 1])             # true\nallsame(length, [1,2], [3,4])  # true\n\nanyeq checks whether an element exists in a collection.\n\nabsdiff computes the absolute difference, with branch-free unsigned integer support.","category":"section"},{"location":"guide/#Type-Utilities","page":"Usage Guide","title":"Type Utilities","text":"div_type determines the appropriate floating-point result type for division. Float types are preserved; integer types promote to Float64.\n\ndiv_type(Int)      # Float64\ndiv_type(Float32)  # Float32","category":"section"},{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#SignalIndices.absdiff-Tuple{Unsigned, Unsigned}","page":"API Reference","title":"SignalIndices.absdiff","text":"absdiff(a, b)\n\nReturn the absolute difference |a - b|. Uses branch-free subtraction for unsigned integers to avoid overflow.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.allsame-Tuple{Function, Any}","page":"API Reference","title":"SignalIndices.allsame","text":"allsame(a::AbstractArray)\nallsame(first, second, others...)\nallsame(f::Function, first, second, others...)\n\nReturn true if all arguments (or elements of a) are equal. The f form compares f(x) values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.anyeq-Tuple{Any, Any}","page":"API Reference","title":"SignalIndices.anyeq","text":"anyeq(el, iter)\n\nReturn true if any element of iter equals el.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.bin_bounds","page":"API Reference","title":"SignalIndices.bin_bounds","text":"bin_bounds(binno, binsize)\nbin_bounds(binno, binsize, max_ndx)\n\nReturn the (start_idx, stop_idx) 1-based index bounds for bin number binno with binsize elements per bin. The three-argument form clamps the result to max_ndx.\n\nSee also bin_center.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.bin_center","page":"API Reference","title":"SignalIndices.bin_center","text":"bin_center(idxs::NTuple{2})\nbin_center(binno, binsize, ...)\n\nReturn the center index of a bin, either from a (start, stop) tuple or by computing bin_bounds first.\n\nSee also bin_bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.centered_basis-Tuple{Any}","page":"API Reference","title":"SignalIndices.centered_basis","text":"centered_basis(n_point)\n\nReturn a range of n_point values centered around zero (e.g., [-1.0, 0.0, 1.0] for n_point=3).\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.clip_ndx","page":"API Reference","title":"SignalIndices.clip_ndx","text":"clip_ndx(ndx, l)\n\nClamp index ndx to the valid range 1:l for an array of length l.\n\nSee also clip_ndx_deviance.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.clip_ndx_deviance-Tuple{Any, Any}","page":"API Reference","title":"SignalIndices.clip_ndx_deviance","text":"clip_ndx_deviance(ndx, l)\n\nLike clip_ndx, but also returns the deviance (clipped - original) as a second value.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.clipsize!-Tuple{AbstractVector, Integer}","page":"API Reference","title":"SignalIndices.clipsize!","text":"clipsize!(a::AbstractVector, n)\n\nResize vector a to length n and release excess memory via sizehint!.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.copy_length_check","page":"API Reference","title":"SignalIndices.copy_length_check","text":"copy_length_check(n_dest, n_source, d_off=1, s_off=1, n=n_ndx(s_off, n_source))\ncopy_length_check(dest::AbstractArray, source::AbstractArray, ...)\ncopy_length_check(dest::AbstractArray, d_off, source::AbstractArray, s_off, ...)\n\nReturn true if dest has enough room to accept n elements copied from source at the given offsets. The three-argument array form interleaves each offset with its array: (dest, d_off, source, s_off, ...).\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.copy_length_dest_check-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"SignalIndices.copy_length_dest_check","text":"copy_length_dest_check(n_dest, d_off, n)\n\nReturn true if a destination of length n_dest can accept n elements starting at offset d_off.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.div_type-Union{Tuple{Type{N}}, Tuple{N}} where N<:AbstractFloat","page":"API Reference","title":"SignalIndices.div_type","text":"div_type(::Type{N})\ndiv_type(::Type{N}, ::Type{D})\ndiv_type(num, den)\n\nReturn the result type of dividing values of the given numeric or array type(s). Float types are preserved; integer types promote to Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.duration-Tuple{Integer, Real}","page":"API Reference","title":"SignalIndices.duration","text":"duration(npoints, fs)\n\nReturn the duration of a regularly sampled time series with npoints samples at sample rate fs. Assumes 1-based indexing, so duration is (npoints - 1) / fs.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.expand_selection-Union{Tuple{T}, NTuple{4, T}} where T<:Integer","page":"API Reference","title":"SignalIndices.expand_selection","text":"expand_selection(ib, ie, imax, expansion)\n\nExpand the index range [ib, ie] by expansion in both directions, clamping to [1, imax]. Returns a tuple (ib_expanded, ie_expanded).\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.filter_no_collisions-Tuple{Any, Any, Any}","page":"API Reference","title":"SignalIndices.filter_no_collisions","text":"filter_no_collisions(as, bs, coll_rad)\n\nFilter elements of as to keep elements that are not within coll_rad of any element in bs. Assumes both are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.filtermap-Tuple{Function, Function, AbstractVector}","page":"API Reference","title":"SignalIndices.filtermap","text":"filtermap(p::Function, f::Function, xs)\n\nFilters the input vector, then maps the remaining values. For each element of xs which predicate function p returns true for, use mapping function f to transform the result.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.find_all_edge_triggers","page":"API Reference","title":"SignalIndices.find_all_edge_triggers","text":"find_all_edge_triggers(arr, thr, comp = >=)\n\nReturn all indices where arr triggers an edge crossing of threshold thr. An edge occurs at index i when comp(arr[i], thr) is true and comp(arr[i-1], thr) is false.\n\nSee also find_first_edge_trigger.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.find_closest","page":"API Reference","title":"SignalIndices.find_closest","text":"find_closest(a, target, ...)\n\nFind the index of the element in a that minimizes the absolute difference from the target.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.find_first_edge_trigger","page":"API Reference","title":"SignalIndices.find_first_edge_trigger","text":"find_first_edge_trigger(arr, thr, comp = >=)\n\nReturn the index of the first edge trigger in arr crossing thr, or nothing if none is found.\n\nSee also find_all_edge_triggers.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.find_local_extrema","page":"API Reference","title":"SignalIndices.find_local_extrema","text":"find_local_extrema(sig, start_ndx=div(length(sig), 2); findmax=true, right_on_ties=true)\n\nStarting from start_ndx, hill-climb through sig to find a local maximum (or minimum if findmax=false). When tied, moves right if right_on_ties=true. Skips missing and NaN values. Returns the index of the found extremum.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.find_not_unique-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"API Reference","title":"SignalIndices.find_not_unique","text":"find_not_unique(a::AbstractArray)\n\nReturns the indices of all redundant elements in a. The time a value is seen, it is not considered redundant\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.find_subseq-Tuple{Any, Any}","page":"API Reference","title":"SignalIndices.find_subseq","text":"find_subseq(subseq, seq)\n\nReturn a vector of starting indices where subseq occurs in seq. Uses isequal for element comparison.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.imap_product-Tuple{Any, Any, Any}","page":"API Reference","title":"SignalIndices.imap_product","text":"imap_product(f, as, bs)\n\nReturn a lazy iterator that applies f(a, b) to every element of the Cartesian product of as and bs.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.indices_above_thresh-Tuple{Any, Any}","page":"API Reference","title":"SignalIndices.indices_above_thresh","text":"indices_above_thresh(arr, thr)\n\nReturn a vector of UnitRange{Int} spans where arr[i] >= thr. Consecutive above-threshold indices are merged into a single range.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.invert_perm-Tuple{Any}","page":"API Reference","title":"SignalIndices.invert_perm","text":"invert_perm(p)\n\nReturn the inverse of permutation vector p, such that invert_perm(p)[p[i]] == i.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.local_extrema","page":"API Reference","title":"SignalIndices.local_extrema","text":"local_extrema(s, comp = >)\n\nReturn indices of local extrema in vector s. An index i is a local extremum when comp(s[i], s[i+1]) is true and comp(s[i-1], s[i]) is false (i.e., a direction change). Use > for maxima (default), < for minima.\n\nNote: plateau-to-descent transitions are reported as extrema. For example, local_extrema([1, 2, 2, 1]) returns [3] because 2 > 1 but !(2 > 2).\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.make_expand_idx-Tuple{Integer, Integer}","page":"API Reference","title":"SignalIndices.make_expand_idx","text":"make_expand_idx(ndims, dimno)\n\nConstruct an index tuple that selects : along dimension dimno and 1 along all other dimensions. Useful for broadcasting a vector along one dimension of an N-dimensional array.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.make_slice_idx-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T<:Union{Integer, OrdinalRange{<:Integer}}","page":"API Reference","title":"SignalIndices.make_slice_idx","text":"make_slice_idx(ndims, dimno, idx)\n\nConstruct a tuple of indices that selects idx along dimension dimno and : along all other dimensions. Useful for programmatic slicing of N-dimensional arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.map_pairwise-Union{Tuple{R}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}, Tuple{F, AbstractVector{T}, Type{R}}} where {F, T, R}","page":"API Reference","title":"SignalIndices.map_pairwise","text":"map_pairwise(f, a, R=eltype(a))\nmap_pairwise(f, as, bs, R=eltype(as))\n\nApply f to all unique pairs from vector a (single-argument form) or to the Cartesian product of as and bs (two-argument form). The single-argument form returns a vector ordered consistently with pairwise_idxs; the two-argument form returns a matrix.\n\nSee also pairwise_idxs, pairwise_idx.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.moving_sum!-Tuple{Any, Any, Any}","page":"API Reference","title":"SignalIndices.moving_sum!","text":"moving_sum!(out, s, nav)\n\nSum s in a sliding window of nav points, placing the result into out. The length of out should be max(length(s) - nav + 1, 0) if nav > 0, or length(s) otherwise. When nav is 0 or 1 the result is a copy of s.\n\nDoes not zero-pad.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.moving_sum-Tuple{AbstractVector, Integer}","page":"API Reference","title":"SignalIndices.moving_sum","text":"moving_sum(s, nav)\n\nSame as moving_sum!, but returns a new array. When nav is 0 or 1 the result is a copy of s.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.n_ndx-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"API Reference","title":"SignalIndices.n_ndx","text":"n_ndx(start_idx::T, stop_idx::T) where {T<:Integer}\n\nFind the number of indices between start_idx and stop_idx.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.ndx_offset-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"API Reference","title":"SignalIndices.ndx_offset","text":"ndx_offset(start_ndx, npt)\n\nFinds the index that will select npt number of elements starting at start_ndx.\n\nIf npt is negative, then start_ndx is treated like the end of a range of elements, and the index required to return npt number of elements is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.ndx_to_t","page":"API Reference","title":"SignalIndices.ndx_to_t","text":"ndx_to_t(i, fs, start_t=0)\n\nConvert a 1-based index (or array of indices) to its time in a regularly sampled time series with sample rate fs and optional start_t.\n\nSee also t_to_ndx, t_to_last_ndx, t_sup_to_ndx.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.ndx_wrap-Union{Tuple{T}, Tuple{T, Integer}} where T<:Integer","page":"API Reference","title":"SignalIndices.ndx_wrap","text":"ndx_wrap(i, max_ndx)\n\nWrap a 1-based index i into the range 1:max_ndx using modular arithmetic.\n\nExamples\n\njulia> SignalIndices.ndx_wrap(5, 3)\n2\n\njulia> SignalIndices.ndx_wrap(3, 3)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.pairwise_idx-Union{Tuple{T}, Tuple{T, T, Any}} where T","page":"API Reference","title":"SignalIndices.pairwise_idx","text":"pairwise_idx(i, j, n)\n\nReturn the linear index into the output of pairwise_idxs for the pair (i, j) where n is the number of input elements. Throws ArgumentError if i == j.\n\nSee also pairwise_idxs, map_pairwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.pairwise_idxs-Tuple{Integer}","page":"API Reference","title":"SignalIndices.pairwise_idxs","text":"pairwise_idxs(n::Integer) -> Vector{NTuple{2, Int}}\n\nReturns the possible combinations of 1:n indices excluding self-pairs. The first index is always greater than the second, allowing for easy subtraction of ordered lists.\n\nExamples\n\njulia> pairwise_idxs(3)\n3-element Vector{Tuple{Int64,Int64}}:\n (2, 1)\n (3, 1)\n (3, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.rev_view-Tuple{AbstractVector}","page":"API Reference","title":"SignalIndices.rev_view","text":"rev_view(a::AbstractVector)\n\nReturn a reversed view of vector a without copying.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.simple_summary_stats-Tuple{AbstractArray}","page":"API Reference","title":"SignalIndices.simple_summary_stats","text":"simple_summary_stats(a)\n\nReturn (mean, std, sem) for array a, where sem is the standard error of the mean.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.skipnothing-Tuple{Any}","page":"API Reference","title":"SignalIndices.skipnothing","text":"skipnothing(itr)\n\nReturn an iterator that skips nothing values in itr. Equivalent to skipoftype(Nothing, itr).\n\nSee also skipoftype.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.skipoftype-Union{Tuple{A}, Tuple{T}, Tuple{Type{T}, A}} where {T, A}","page":"API Reference","title":"SignalIndices.skipoftype","text":"skipoftype(::Type{T}, itr)\n\nReturn an iterator over the elements in itr skipping values of type T. Use collect to obtain an Array containing the non-T values in itr. Note that even if itr is a multidimensional array, the result will always be a Vector since it is not possible to remove nothings while preserving dimensions of the input.\n\nExamples\n\njulia> sum(SignalIndices.skipoftype(nothing, [1, nothing, 2]))\n3\njulia> collect(SignalIndices.skipoftype(nothing, [1, nothing, 2]))\n2-element Vector{Int64}:\n 1\n 2\njulia> collect(SignalIndices.skipoftype(nothing, [1 nothing; 2 nothing]))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.stepsize-Tuple{StepRangeLen}","page":"API Reference","title":"SignalIndices.stepsize","text":"stepsize(r)\n\nReturn the step size of a range or regularly sampled vector. For a UnitRange, returns 1. For a generic vector, returns a[2] - a[1] (assumes regular spacing).\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.subselect-Union{Tuple{T}, Tuple{Any, AbstractVector{<:Tuple{T, T} where T}}, Tuple{Any, AbstractVector{<:Tuple{T, T} where T}, Type{T}}} where T<:(AbstractVector)","page":"API Reference","title":"SignalIndices.subselect","text":"subselect(base_vec, idx_tup_vec, outtype=...)\n\nExtract sub-vectors from base_vec using a vector of (start, stop) index tuples. Returns a Vector{outtype} where each element is the slice base_vec[start:stop].\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.t_sup_to_ndx","page":"API Reference","title":"SignalIndices.t_sup_to_ndx","text":"t_sup_to_ndx(x, fs, start_t=0, T=Int)\n\nConvert a time to the index of the last sample strictly before the specified time in a regularly sampled time series. Equivalent to t_to_ndx(...) - 1.\n\nSee also t_to_ndx, t_to_last_ndx, ndx_to_t.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.t_to_last_ndx","page":"API Reference","title":"SignalIndices.t_to_last_ndx","text":"t_to_last_ndx(x, fs, start_t=0, T=Int)\n\nLike t_to_ndx, but returns the index of the last sample at or before the specified time.\n\nSee also ndx_to_t, t_sup_to_ndx.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.t_to_ndx","page":"API Reference","title":"SignalIndices.t_to_ndx","text":"t_to_ndx(x, fs, start_t=0, T=Int)\n\nConvert a time to its 1-based index in a regularly sampled time series. Returns the index of the first sample at or after the specified time.\n\nSee also ndx_to_t, t_to_last_ndx, t_sup_to_ndx.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.thresh_cross","page":"API Reference","title":"SignalIndices.thresh_cross","text":"thresh_cross(arr, thresh, comp = <)\n\nReturn indices where arr crosses upward through thresh according to comp. An index i+1 is returned when comp(arr[i], thresh) is true and comp(arr[i+1], thresh) is false (i.e., the signal leaves the comp region).\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.time_interval","page":"API Reference","title":"SignalIndices.time_interval","text":"time_interval(npoints, fs, start_t=0)\ntime_interval(a::AbstractVector, fs, start_t=0)\n\nReturn the (start_t, end_t) time interval of a regularly sampled time series with npoints samples (or a vector a) at sample rate fs.\n\n\n\n\n\n","category":"function"},{"location":"api/#SignalIndices.trailing_zeros_idx-Tuple{Any}","page":"API Reference","title":"SignalIndices.trailing_zeros_idx","text":"trailing_zeros_idx(arr)\n\nreturn last index that is not zero\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.uniformhist!-Tuple{Any, Any, Any}","page":"API Reference","title":"SignalIndices.uniformhist!","text":"uniformhist!(cnts, xs, r)\n\nCompute a histogram of xs into pre-allocated count vector cnts, using the bin edges defined by range r. Bins are left-inclusive: a value x falls into bin i when r[i] <= x < r[i+1].\n\nr must have uniform step size (e.g. a StepRangeLen or UnitRange) and at least 2 elements. The length of cnts must equal length(r) - 1. Values outside the range are silently ignored.\n\ncnts is not zeroed before accumulation, so it must be initialized (e.g. with zeros). This also means uniformhist! can be called repeatedly to accumulate counts from multiple datasets.\n\nUses multiplication by the reciprocal of the step size instead of division for a ~20x speedup over naive binning.\n\nSee also uniformhist.\n\nExamples\n\njulia> cnts = zeros(Int, 3);\n\njulia> uniformhist!(cnts, [0.1, 0.5, 1.2, 2.9], 0.0:1.0:3.0)\n3-element Vector{Int64}:\n 2\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.uniformhist-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T","page":"API Reference","title":"SignalIndices.uniformhist","text":"uniformhist([::Type{T} = Int,] xs, r) where T\n\nCompute a histogram of xs using the bin edges defined by range r, returning a new vector of counts with element type T (default Int). Bins are left-inclusive: a value x falls into bin i when r[i] <= x < r[i+1].\n\nr must have uniform step size (e.g. a StepRangeLen or UnitRange). The returned vector has length length(r) - 1. Values outside the range are silently ignored.\n\nSee also uniformhist!.\n\nExamples\n\njulia> uniformhist([0.1, 0.5, 1.2, 2.9], 0.0:1.0:3.0)\n3-element Vector{Int64}:\n 2\n 1\n 1\n\njulia> uniformhist(Float64, [1, 1, 2, 3, 3, 3], 1:4)\n3-element Vector{Float64}:\n 2.0\n 1.0\n 3.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.view_trailing_slice-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{<:Any, N}, T}} where {N, T<:Union{Integer, OrdinalRange{<:Integer}}}","page":"API Reference","title":"SignalIndices.view_trailing_slice","text":"view_trailing_slice(a::AbstractArray{<:Any,N}, idx)\n\nReturn a view of a sliced along its last dimension at idx, with all leading dimensions selected via :. For a 3D array, this is equivalent to view(a, :, :, idx).\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.weighted_mean-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}, T}} where {E<:Number, N, T<:Number}","page":"API Reference","title":"SignalIndices.weighted_mean","text":"weighted_mean(summand, weights, total_weight=sum(weights))\n\nCompute the weighted mean of summand using element-wise weights. Both arrays must have the same size. Returns a scalar.\n\nSee also weighted_mean_dim.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.weighted_mean_dim-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractVector{T}}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer, T}} where {E<:Number, N, T<:Number}","page":"API Reference","title":"SignalIndices.weighted_mean_dim","text":"weighted_mean_dim(summand, weights, dim=N, total_weight=sum(weights))\n\nCompute the weighted mean of summand along dimension dim using weights (a vector whose length matches size(summand, dim)). Returns an array with dimension dim reduced to size 1.\n\nSee also weighted_mean.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.window_counts-NTuple{4, Any}","page":"API Reference","title":"SignalIndices.window_counts","text":"window_counts in a certain range`\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.window_counts-Tuple{Any, Any}","page":"API Reference","title":"SignalIndices.window_counts","text":"window_counts(ts, window_dur)\n\nFor each event in ts, count the number of events in ts that are in the range of ts[i] and ts[i] + window_dur. Assumes ts is sorted, and that elements of ts are unique.\n\n\n\n\n\n","category":"method"},{"location":"#SignalIndices.jl","page":"Home","title":"SignalIndices.jl","text":"Low-level building blocks for regularly sampled time series — index/time conversion, threshold detection, sliding windows, and array utilities. Designed for neuroscience and electrophysiology workflows where data is sampled at a known frequency and stored in plain Julia arrays.","category":"section"},{"location":"#Design-Principles","page":"Home","title":"Design Principles","text":"Plain arrays, not signal types — works with standard Julia arrays, computing times from indices and sample rates rather than wrapping data in custom types.\n1-based index convention — all functions assume Julia's native 1-based indexing. Index 1 corresponds to start_t.\nAllocation-conscious — in-place variants (moving_sum!, uniformhist!) and pre-sized outputs where possible.\nComposable primitives — small functions that chain together rather than monolithic signal processing pipelines.","category":"section"},{"location":"#Example-Workflow","page":"Home","title":"Example Workflow","text":"A typical neuroscience analysis: load spike times, convert to indices, detect threshold crossings, and build a histogram.\n\nusing SignalIndices\n\nfs = 30_000.0   # 30 kHz sampling rate\nstart_t = 0.0\n\n# Convert event times (seconds) to sample indices\nspike_indices = t_to_ndx([0.103, 0.207, 0.515], fs, start_t)\n\n# Convert back to verify\nspike_times = ndx_to_t(spike_indices, fs, start_t)\n\n# Detect where a filtered signal crosses a threshold\nedges = find_all_edge_triggers(filtered_signal, 3.5)\n\n# Smooth with a sliding window, then find local maxima\nsmoothed = moving_sum(raw_signal, 50)\npeaks = local_extrema(smoothed)\n\n# Build a peri-stimulus time histogram\ncounts = uniformhist(spike_times, 0.0:0.001:1.0)","category":"section"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"Usage Guide — categorized function reference with examples\nAPI Reference — complete docstrings for every exported function","category":"section"}]
}
