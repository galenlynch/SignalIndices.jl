<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SignalIndices.jl</title><meta name="title" content="API Reference · SignalIndices.jl"/><meta property="og:title" content="API Reference · SignalIndices.jl"/><meta property="twitter:title" content="API Reference · SignalIndices.jl"/><meta name="description" content="Documentation for SignalIndices.jl."/><meta property="og:description" content="Documentation for SignalIndices.jl."/><meta property="twitter:description" content="Documentation for SignalIndices.jl."/><meta property="og:url" content="https://galenlynch.github.io/SignalIndices.jl/api/"/><meta property="twitter:url" content="https://galenlynch.github.io/SignalIndices.jl/api/"/><link rel="canonical" href="https://galenlynch.github.io/SignalIndices.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SignalIndices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Usage Guide</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/galenlynch/SignalIndices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/galenlynch/SignalIndices.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">API Reference</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><ul><li><a href="#SignalIndices.absdiff-Tuple{Unsigned, Unsigned}"><code>SignalIndices.absdiff</code></a></li><li><a href="#SignalIndices.allsame-Tuple{Function, Any}"><code>SignalIndices.allsame</code></a></li><li><a href="#SignalIndices.anyeq-Tuple{Any, Any}"><code>SignalIndices.anyeq</code></a></li><li><a href="#SignalIndices.bin_bounds"><code>SignalIndices.bin_bounds</code></a></li><li><a href="#SignalIndices.bin_center"><code>SignalIndices.bin_center</code></a></li><li><a href="#SignalIndices.centered_basis-Tuple{Any}"><code>SignalIndices.centered_basis</code></a></li><li><a href="#SignalIndices.clip_ndx"><code>SignalIndices.clip_ndx</code></a></li><li><a href="#SignalIndices.clip_ndx_deviance-Tuple{Any, Any}"><code>SignalIndices.clip_ndx_deviance</code></a></li><li><a href="#SignalIndices.clipsize!-Tuple{AbstractVector, Integer}"><code>SignalIndices.clipsize!</code></a></li><li><a href="#SignalIndices.copy_length_check"><code>SignalIndices.copy_length_check</code></a></li><li><a href="#SignalIndices.copy_length_dest_check-Tuple{Integer, Integer, Integer}"><code>SignalIndices.copy_length_dest_check</code></a></li><li><a href="#SignalIndices.div_type-Union{Tuple{Type{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>SignalIndices.div_type</code></a></li><li><a href="#SignalIndices.duration-Tuple{Integer, Real}"><code>SignalIndices.duration</code></a></li><li><a href="#SignalIndices.expand_selection-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Integer"><code>SignalIndices.expand_selection</code></a></li><li><a href="#SignalIndices.filter_no_collisions-Tuple{Any, Any, Any}"><code>SignalIndices.filter_no_collisions</code></a></li><li><a href="#SignalIndices.filtermap-Tuple{Function, Function, AbstractVector}"><code>SignalIndices.filtermap</code></a></li><li><a href="#SignalIndices.find_all_edge_triggers"><code>SignalIndices.find_all_edge_triggers</code></a></li><li><a href="#SignalIndices.find_closest"><code>SignalIndices.find_closest</code></a></li><li><a href="#SignalIndices.find_first_edge_trigger"><code>SignalIndices.find_first_edge_trigger</code></a></li><li><a href="#SignalIndices.find_local_extrema"><code>SignalIndices.find_local_extrema</code></a></li><li><a href="#SignalIndices.find_not_unique-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>SignalIndices.find_not_unique</code></a></li><li><a href="#SignalIndices.find_subseq-Tuple{Any, Any}"><code>SignalIndices.find_subseq</code></a></li><li><a href="#SignalIndices.imap_product-Tuple{Any, Any, Any}"><code>SignalIndices.imap_product</code></a></li><li><a href="#SignalIndices.indices_above_thresh-Tuple{Any, Any}"><code>SignalIndices.indices_above_thresh</code></a></li><li><a href="#SignalIndices.invert_perm-Tuple{Any}"><code>SignalIndices.invert_perm</code></a></li><li><a href="#SignalIndices.local_extrema"><code>SignalIndices.local_extrema</code></a></li><li><a href="#SignalIndices.make_expand_idx-Tuple{Integer, Integer}"><code>SignalIndices.make_expand_idx</code></a></li><li><a href="#SignalIndices.make_slice_idx-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T&lt;:Union{Integer, OrdinalRange{&lt;:Integer}}"><code>SignalIndices.make_slice_idx</code></a></li><li><a href="#SignalIndices.map_pairwise-Union{Tuple{R}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}, Tuple{F, AbstractVector{T}, Type{R}}} where {F, T, R}"><code>SignalIndices.map_pairwise</code></a></li><li><a href="#SignalIndices.moving_sum-Tuple{AbstractVector, Integer}"><code>SignalIndices.moving_sum</code></a></li><li><a href="#SignalIndices.moving_sum!-Tuple{Any, Any, Any}"><code>SignalIndices.moving_sum!</code></a></li><li><a href="#SignalIndices.n_ndx-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>SignalIndices.n_ndx</code></a></li><li><a href="#SignalIndices.ndx_offset-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>SignalIndices.ndx_offset</code></a></li><li><a href="#SignalIndices.ndx_to_t"><code>SignalIndices.ndx_to_t</code></a></li><li><a href="#SignalIndices.ndx_wrap-Union{Tuple{T}, Tuple{T, Integer}} where T&lt;:Integer"><code>SignalIndices.ndx_wrap</code></a></li><li><a href="#SignalIndices.pairwise_idx-Union{Tuple{T}, Tuple{T, T, Any}} where T"><code>SignalIndices.pairwise_idx</code></a></li><li><a href="#SignalIndices.pairwise_idxs-Tuple{Integer}"><code>SignalIndices.pairwise_idxs</code></a></li><li><a href="#SignalIndices.rev_view-Tuple{AbstractVector}"><code>SignalIndices.rev_view</code></a></li><li><a href="#SignalIndices.simple_summary_stats-Tuple{AbstractArray}"><code>SignalIndices.simple_summary_stats</code></a></li><li><a href="#SignalIndices.skipnothing-Tuple{Any}"><code>SignalIndices.skipnothing</code></a></li><li><a href="#SignalIndices.skipoftype-Union{Tuple{A}, Tuple{T}, Tuple{Type{T}, A}} where {T, A}"><code>SignalIndices.skipoftype</code></a></li><li><a href="#SignalIndices.stepsize-Tuple{StepRangeLen}"><code>SignalIndices.stepsize</code></a></li><li><a href="#SignalIndices.subselect-Union{Tuple{T}, Tuple{Any, AbstractVector{&lt;:Tuple{T, T} where T}}, Tuple{Any, AbstractVector{&lt;:Tuple{T, T} where T}, Type{T}}} where T&lt;:(AbstractVector)"><code>SignalIndices.subselect</code></a></li><li><a href="#SignalIndices.t_sup_to_ndx"><code>SignalIndices.t_sup_to_ndx</code></a></li><li><a href="#SignalIndices.t_to_last_ndx"><code>SignalIndices.t_to_last_ndx</code></a></li><li><a href="#SignalIndices.t_to_ndx"><code>SignalIndices.t_to_ndx</code></a></li><li><a href="#SignalIndices.thresh_cross"><code>SignalIndices.thresh_cross</code></a></li><li><a href="#SignalIndices.time_interval"><code>SignalIndices.time_interval</code></a></li><li><a href="#SignalIndices.trailing_zeros_idx-Tuple{Any}"><code>SignalIndices.trailing_zeros_idx</code></a></li><li><a href="#SignalIndices.uniformhist-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T"><code>SignalIndices.uniformhist</code></a></li><li><a href="#SignalIndices.uniformhist!-Tuple{Any, Any, Any}"><code>SignalIndices.uniformhist!</code></a></li><li><a href="#SignalIndices.view_trailing_slice-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{&lt;:Any, N}, T}} where {N, T&lt;:Union{Integer, OrdinalRange{&lt;:Integer}}}"><code>SignalIndices.view_trailing_slice</code></a></li><li><a href="#SignalIndices.weighted_mean-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}, T}} where {E&lt;:Number, N, T&lt;:Number}"><code>SignalIndices.weighted_mean</code></a></li><li><a href="#SignalIndices.weighted_mean_dim-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractVector{T}}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer, T}} where {E&lt;:Number, N, T&lt;:Number}"><code>SignalIndices.weighted_mean_dim</code></a></li><li><a href="#SignalIndices.window_counts-Tuple{Any, Any}"><code>SignalIndices.window_counts</code></a></li><li><a href="#SignalIndices.window_counts-NTuple{4, Any}"><code>SignalIndices.window_counts</code></a></li></ul><article><details class="docstring" open="true"><summary id="SignalIndices.absdiff-Tuple{Unsigned, Unsigned}"><a class="docstring-binding" href="#SignalIndices.absdiff-Tuple{Unsigned, Unsigned}"><code>SignalIndices.absdiff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">absdiff(a, b)</code></pre><p>Return the absolute difference <code>|a - b|</code>. Uses branch-free subtraction for unsigned integers to avoid overflow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1415-L1420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.allsame-Tuple{Function, Any}"><a class="docstring-binding" href="#SignalIndices.allsame-Tuple{Function, Any}"><code>SignalIndices.allsame</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">allsame(a::AbstractArray)
allsame(first, second, others...)
allsame(f::Function, first, second, others...)</code></pre><p>Return <code>true</code> if all arguments (or elements of <code>a</code>) are equal. The <code>f</code> form compares <code>f(x)</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1381-L1388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.anyeq-Tuple{Any, Any}"><a class="docstring-binding" href="#SignalIndices.anyeq-Tuple{Any, Any}"><code>SignalIndices.anyeq</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">anyeq(el, iter)</code></pre><p>Return <code>true</code> if any element of <code>iter</code> equals <code>el</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1408-L1412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.bin_bounds"><a class="docstring-binding" href="#SignalIndices.bin_bounds"><code>SignalIndices.bin_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bin_bounds(binno, binsize)
bin_bounds(binno, binsize, max_ndx)</code></pre><p>Return the <code>(start_idx, stop_idx)</code> 1-based index bounds for bin number <code>binno</code> with <code>binsize</code> elements per bin. The three-argument form clamps the result to <code>max_ndx</code>.</p><p>See also <a href="#SignalIndices.bin_center"><code>bin_center</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L286-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.bin_center"><a class="docstring-binding" href="#SignalIndices.bin_center"><code>SignalIndices.bin_center</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bin_center(idxs::NTuple{2})
bin_center(binno, binsize, ...)</code></pre><p>Return the center index of a bin, either from a <code>(start, stop)</code> tuple or by computing <a href="#SignalIndices.bin_bounds"><code>bin_bounds</code></a> first.</p><p>See also <a href="#SignalIndices.bin_bounds"><code>bin_bounds</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L314-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.centered_basis-Tuple{Any}"><a class="docstring-binding" href="#SignalIndices.centered_basis-Tuple{Any}"><code>SignalIndices.centered_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">centered_basis(n_point)</code></pre><p>Return a range of <code>n_point</code> values centered around zero (e.g., <code>[-1.0, 0.0, 1.0]</code> for <code>n_point=3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1034-L1039">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.clip_ndx"><a class="docstring-binding" href="#SignalIndices.clip_ndx"><code>SignalIndices.clip_ndx</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clip_ndx(ndx, l)</code></pre><p>Clamp index <code>ndx</code> to the valid range <code>1:l</code> for an array of length <code>l</code>.</p><p>See also <a href="#SignalIndices.clip_ndx_deviance-Tuple{Any, Any}"><code>clip_ndx_deviance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L204-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.clip_ndx_deviance-Tuple{Any, Any}"><a class="docstring-binding" href="#SignalIndices.clip_ndx_deviance-Tuple{Any, Any}"><code>SignalIndices.clip_ndx_deviance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clip_ndx_deviance(ndx, l)</code></pre><p>Like <a href="#SignalIndices.clip_ndx"><code>clip_ndx</code></a>, but also returns the deviance (clipped - original) as a second value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L215-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.clipsize!-Tuple{AbstractVector, Integer}"><a class="docstring-binding" href="#SignalIndices.clipsize!-Tuple{AbstractVector, Integer}"><code>SignalIndices.clipsize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clipsize!(a::AbstractVector, n)</code></pre><p>Resize vector <code>a</code> to length <code>n</code> and release excess memory via <code>sizehint!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1308-L1312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.copy_length_check"><a class="docstring-binding" href="#SignalIndices.copy_length_check"><code>SignalIndices.copy_length_check</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">copy_length_check(n_dest, n_source, d_off=1, s_off=1, n=n_ndx(s_off, n_source))
copy_length_check(dest::AbstractArray, source::AbstractArray, ...)
copy_length_check(dest::AbstractArray, d_off, source::AbstractArray, s_off, ...)</code></pre><p>Return <code>true</code> if <code>dest</code> has enough room to accept <code>n</code> elements copied from <code>source</code> at the given offsets. The three-argument array form interleaves each offset with its array: <code>(dest, d_off, source, s_off, ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L397-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.copy_length_dest_check-Tuple{Integer, Integer, Integer}"><a class="docstring-binding" href="#SignalIndices.copy_length_dest_check-Tuple{Integer, Integer, Integer}"><code>SignalIndices.copy_length_dest_check</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy_length_dest_check(n_dest, d_off, n)</code></pre><p>Return <code>true</code> if a destination of length <code>n_dest</code> can accept <code>n</code> elements starting at offset <code>d_off</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L408-L413">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.div_type-Union{Tuple{Type{N}}, Tuple{N}} where N&lt;:AbstractFloat"><a class="docstring-binding" href="#SignalIndices.div_type-Union{Tuple{Type{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>SignalIndices.div_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">div_type(::Type{N})
div_type(::Type{N}, ::Type{D})
div_type(num, den)</code></pre><p>Return the result type of dividing values of the given numeric or array type(s). Float types are preserved; integer types promote to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L82-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.duration-Tuple{Integer, Real}"><a class="docstring-binding" href="#SignalIndices.duration-Tuple{Integer, Real}"><code>SignalIndices.duration</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">duration(npoints, fs)</code></pre><p>Return the duration of a regularly sampled time series with <code>npoints</code> samples at sample rate <code>fs</code>. Assumes 1-based indexing, so duration is <code>(npoints - 1) / fs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L262-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.expand_selection-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Integer"><a class="docstring-binding" href="#SignalIndices.expand_selection-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Integer"><code>SignalIndices.expand_selection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expand_selection(ib, ie, imax, expansion)</code></pre><p>Expand the index range <code>[ib, ie]</code> by <code>expansion</code> in both directions, clamping to <code>[1, imax]</code>. Returns a tuple <code>(ib_expanded, ie_expanded)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L233-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.filter_no_collisions-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#SignalIndices.filter_no_collisions-Tuple{Any, Any, Any}"><code>SignalIndices.filter_no_collisions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter_no_collisions(as, bs, coll_rad)</code></pre><p>Filter elements of <code>as</code> to keep elements that are not within <code>coll_rad</code> of any element in <code>bs</code>. Assumes both are sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1184-L1189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.filtermap-Tuple{Function, Function, AbstractVector}"><a class="docstring-binding" href="#SignalIndices.filtermap-Tuple{Function, Function, AbstractVector}"><code>SignalIndices.filtermap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filtermap(p::Function, f::Function, xs)</code></pre><p>Filters the input vector, then maps the remaining values. For each element of <code>xs</code> which predicate function <code>p</code> returns true for, use mapping function <code>f</code> to transform the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1244-L1249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.find_all_edge_triggers"><a class="docstring-binding" href="#SignalIndices.find_all_edge_triggers"><code>SignalIndices.find_all_edge_triggers</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_all_edge_triggers(arr, thr, comp = &gt;=)</code></pre><p>Return all indices where <code>arr</code> triggers an edge crossing of threshold <code>thr</code>. An edge occurs at index <code>i</code> when <code>comp(arr[i], thr)</code> is true and <code>comp(arr[i-1], thr)</code> is false.</p><p>See also <a href="#SignalIndices.find_first_edge_trigger"><code>find_first_edge_trigger</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1315-L1323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.find_closest"><a class="docstring-binding" href="#SignalIndices.find_closest"><code>SignalIndices.find_closest</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_closest(a, target, ...)</code></pre><p>Find the index of the element in <code>a</code> that minimizes the absolute difference from the target.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L772-L777">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.find_first_edge_trigger"><a class="docstring-binding" href="#SignalIndices.find_first_edge_trigger"><code>SignalIndices.find_first_edge_trigger</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_first_edge_trigger(arr, thr, comp = &gt;=)</code></pre><p>Return the index of the first edge trigger in <code>arr</code> crossing <code>thr</code>, or <code>nothing</code> if none is found.</p><p>See also <a href="#SignalIndices.find_all_edge_triggers"><code>find_all_edge_triggers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1334-L1341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.find_local_extrema"><a class="docstring-binding" href="#SignalIndices.find_local_extrema"><code>SignalIndices.find_local_extrema</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_local_extrema(sig, start_ndx=div(length(sig), 2); findmax=true, right_on_ties=true)</code></pre><p>Starting from <code>start_ndx</code>, hill-climb through <code>sig</code> to find a local maximum (or minimum if <code>findmax=false</code>). When tied, moves right if <code>right_on_ties=true</code>. Skips <code>missing</code> and <code>NaN</code> values. Returns the index of the found extremum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1137-L1143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.find_not_unique-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#SignalIndices.find_not_unique-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>SignalIndices.find_not_unique</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_not_unique(a::AbstractArray)</code></pre><p>Returns the indices of all redundant elements in a. The time a value is seen, it is not considered redundant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1275-L1280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.find_subseq-Tuple{Any, Any}"><a class="docstring-binding" href="#SignalIndices.find_subseq-Tuple{Any, Any}"><code>SignalIndices.find_subseq</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subseq(subseq, seq)</code></pre><p>Return a vector of starting indices where <code>subseq</code> occurs in <code>seq</code>. Uses <code>isequal</code> for element comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L682-L687">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.imap_product-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#SignalIndices.imap_product-Tuple{Any, Any, Any}"><code>SignalIndices.imap_product</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">imap_product(f, as, bs)</code></pre><p>Return a lazy iterator that applies <code>f(a, b)</code> to every element of the Cartesian product of <code>as</code> and <code>bs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L674-L679">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.indices_above_thresh-Tuple{Any, Any}"><a class="docstring-binding" href="#SignalIndices.indices_above_thresh-Tuple{Any, Any}"><code>SignalIndices.indices_above_thresh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indices_above_thresh(arr, thr)</code></pre><p>Return a vector of <code>UnitRange{Int}</code> spans where <code>arr[i] &gt;= thr</code>. Consecutive above-threshold indices are merged into a single range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1351-L1356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.invert_perm-Tuple{Any}"><a class="docstring-binding" href="#SignalIndices.invert_perm-Tuple{Any}"><code>SignalIndices.invert_perm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">invert_perm(p)</code></pre><p>Return the inverse of permutation vector <code>p</code>, such that <code>invert_perm(p)[p[i]] == i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L460-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.local_extrema"><a class="docstring-binding" href="#SignalIndices.local_extrema"><code>SignalIndices.local_extrema</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">local_extrema(s, comp = &gt;)</code></pre><p>Return indices of local extrema in vector <code>s</code>. An index <code>i</code> is a local extremum when <code>comp(s[i], s[i+1])</code> is true and <code>comp(s[i-1], s[i])</code> is false (i.e., a direction change). Use <code>&gt;</code> for maxima (default), <code>&lt;</code> for minima.</p><p>Note: plateau-to-descent transitions are reported as extrema. For example, <code>local_extrema([1, 2, 2, 1])</code> returns <code>[3]</code> because <code>2 &gt; 1</code> but <code>!(2 &gt; 2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L551-L560">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.make_expand_idx-Tuple{Integer, Integer}"><a class="docstring-binding" href="#SignalIndices.make_expand_idx-Tuple{Integer, Integer}"><code>SignalIndices.make_expand_idx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_expand_idx(ndims, dimno)</code></pre><p>Construct an index tuple that selects <code>:</code> along dimension <code>dimno</code> and <code>1</code> along all other dimensions. Useful for broadcasting a vector along one dimension of an N-dimensional array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L383-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.make_slice_idx-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T&lt;:Union{Integer, OrdinalRange{&lt;:Integer}}"><a class="docstring-binding" href="#SignalIndices.make_slice_idx-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T&lt;:Union{Integer, OrdinalRange{&lt;:Integer}}"><code>SignalIndices.make_slice_idx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_slice_idx(ndims, dimno, idx)</code></pre><p>Construct a tuple of indices that selects <code>idx</code> along dimension <code>dimno</code> and <code>:</code> along all other dimensions. Useful for programmatic slicing of N-dimensional arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L366-L371">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.map_pairwise-Union{Tuple{R}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}, Tuple{F, AbstractVector{T}, Type{R}}} where {F, T, R}"><a class="docstring-binding" href="#SignalIndices.map_pairwise-Union{Tuple{R}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}, Tuple{F, AbstractVector{T}, Type{R}}} where {F, T, R}"><code>SignalIndices.map_pairwise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">map_pairwise(f, a, R=eltype(a))
map_pairwise(f, as, bs, R=eltype(as))</code></pre><p>Apply <code>f</code> to all unique pairs from vector <code>a</code> (single-argument form) or to the Cartesian product of <code>as</code> and <code>bs</code> (two-argument form). The single-argument form returns a vector ordered consistently with <a href="#SignalIndices.pairwise_idxs-Tuple{Integer}"><code>pairwise_idxs</code></a>; the two-argument form returns a matrix.</p><p>See also <a href="#SignalIndices.pairwise_idxs-Tuple{Integer}"><code>pairwise_idxs</code></a>, <a href="#SignalIndices.pairwise_idx-Union{Tuple{T}, Tuple{T, T, Any}} where T"><code>pairwise_idx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L633-L643">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.moving_sum!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#SignalIndices.moving_sum!-Tuple{Any, Any, Any}"><code>SignalIndices.moving_sum!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">moving_sum!(out, s, nav)</code></pre><p>Sum <code>s</code> in a sliding window of <code>nav</code> points, placing the result into <code>out</code>. The length of <code>out</code> should be <code>max(length(s) - nav + 1, 0)</code> if <code>nav &gt; 0</code>, or <code>length(s)</code> otherwise. When <code>nav</code> is 0 or 1 the result is a copy of <code>s</code>.</p><p>Does not zero-pad.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L967-L975">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.moving_sum-Tuple{AbstractVector, Integer}"><a class="docstring-binding" href="#SignalIndices.moving_sum-Tuple{AbstractVector, Integer}"><code>SignalIndices.moving_sum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">moving_sum(s, nav)</code></pre><p>Same as <a href="#SignalIndices.moving_sum!-Tuple{Any, Any, Any}"><code>moving_sum!</code></a>, but returns a new array. When <code>nav</code> is 0 or 1 the result is a copy of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L986-L991">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.n_ndx-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><a class="docstring-binding" href="#SignalIndices.n_ndx-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>SignalIndices.n_ndx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n_ndx(start_idx::T, stop_idx::T) where {T&lt;:Integer}</code></pre><p>Find the number of indices between <code>start_idx</code> and <code>stop_idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L226-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.ndx_offset-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><a class="docstring-binding" href="#SignalIndices.ndx_offset-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>SignalIndices.ndx_offset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ndx_offset(start_ndx, npt)</code></pre><p>Finds the index that will select npt number of elements starting at start_ndx.</p><p>If npt is negative, then start_ndx is treated like the end of a range of elements, and the index required to return npt number of elements is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L249-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.ndx_to_t"><a class="docstring-binding" href="#SignalIndices.ndx_to_t"><code>SignalIndices.ndx_to_t</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ndx_to_t(i, fs, start_t=0)</code></pre><p>Convert a 1-based index (or array of indices) to its time in a regularly sampled time series with sample rate <code>fs</code> and optional <code>start_t</code>.</p><p>See also <a href="#SignalIndices.t_to_ndx"><code>t_to_ndx</code></a>, <a href="#SignalIndices.t_to_last_ndx"><code>t_to_last_ndx</code></a>, <a href="#SignalIndices.t_sup_to_ndx"><code>t_sup_to_ndx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L104-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.ndx_wrap-Union{Tuple{T}, Tuple{T, Integer}} where T&lt;:Integer"><a class="docstring-binding" href="#SignalIndices.ndx_wrap-Union{Tuple{T}, Tuple{T, Integer}} where T&lt;:Integer"><code>SignalIndices.ndx_wrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ndx_wrap(i, max_ndx)</code></pre><p>Wrap a 1-based index <code>i</code> into the range <code>1:max_ndx</code> using modular arithmetic.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SignalIndices.ndx_wrap(5, 3)
2

julia&gt; SignalIndices.ndx_wrap(3, 3)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L442-L455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.pairwise_idx-Union{Tuple{T}, Tuple{T, T, Any}} where T"><a class="docstring-binding" href="#SignalIndices.pairwise_idx-Union{Tuple{T}, Tuple{T, T, Any}} where T"><code>SignalIndices.pairwise_idx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pairwise_idx(i, j, n)</code></pre><p>Return the linear index into the output of <a href="#SignalIndices.pairwise_idxs-Tuple{Integer}"><code>pairwise_idxs</code></a> for the pair <code>(i, j)</code> where <code>n</code> is the number of input elements. Throws <code>ArgumentError</code> if <code>i == j</code>.</p><p>See also <a href="#SignalIndices.pairwise_idxs-Tuple{Integer}"><code>pairwise_idxs</code></a>, <a href="#SignalIndices.map_pairwise-Union{Tuple{R}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}, Tuple{F, AbstractVector{T}, Type{R}}} where {F, T, R}"><code>map_pairwise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L618-L626">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.pairwise_idxs-Tuple{Integer}"><a class="docstring-binding" href="#SignalIndices.pairwise_idxs-Tuple{Integer}"><code>SignalIndices.pairwise_idxs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pairwise_idxs(n::Integer) -&gt; Vector{NTuple{2, Int}}</code></pre><p>Returns the possible combinations of <code>1:n</code> indices excluding self-pairs. The first index is always greater than the second, allowing for easy subtraction of ordered lists.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pairwise_idxs(3)
3-element Vector{Tuple{Int64,Int64}}:
 (2, 1)
 (3, 1)
 (3, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L587-L602">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.rev_view-Tuple{AbstractVector}"><a class="docstring-binding" href="#SignalIndices.rev_view-Tuple{AbstractVector}"><code>SignalIndices.rev_view</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rev_view(a::AbstractVector)</code></pre><p>Return a reversed view of vector <code>a</code> without copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L580-L584">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.simple_summary_stats-Tuple{AbstractArray}"><a class="docstring-binding" href="#SignalIndices.simple_summary_stats-Tuple{AbstractArray}"><code>SignalIndices.simple_summary_stats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simple_summary_stats(a)</code></pre><p>Return <code>(mean, std, sem)</code> for array <code>a</code>, where <code>sem</code> is the standard error of the mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L759-L764">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.skipnothing-Tuple{Any}"><a class="docstring-binding" href="#SignalIndices.skipnothing-Tuple{Any}"><code>SignalIndices.skipnothing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">skipnothing(itr)</code></pre><p>Return an iterator that skips <code>nothing</code> values in <code>itr</code>. Equivalent to <code>skipoftype(Nothing, itr)</code>.</p><p>See also <a href="#SignalIndices.skipoftype-Union{Tuple{A}, Tuple{T}, Tuple{Type{T}, A}} where {T, A}"><code>skipoftype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L940-L947">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.skipoftype-Union{Tuple{A}, Tuple{T}, Tuple{Type{T}, A}} where {T, A}"><a class="docstring-binding" href="#SignalIndices.skipoftype-Union{Tuple{A}, Tuple{T}, Tuple{Type{T}, A}} where {T, A}"><code>SignalIndices.skipoftype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">skipoftype(::Type{T}, itr)</code></pre><p>Return an iterator over the elements in <code>itr</code> skipping values of type <code>T</code>. Use <code>collect</code> to obtain an <code>Array</code> containing the non-<code>T</code> values in <code>itr</code>. Note that even if <code>itr</code> is a multidimensional array, the result will always be a <code>Vector</code> since it is not possible to remove nothings while preserving dimensions of the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sum(SignalIndices.skipoftype(nothing, [1, nothing, 2]))
3
julia&gt; collect(SignalIndices.skipoftype(nothing, [1, nothing, 2]))
2-element Vector{Int64}:
 1
 2
julia&gt; collect(SignalIndices.skipoftype(nothing, [1 nothing; 2 nothing]))
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L792-L812">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.stepsize-Tuple{StepRangeLen}"><a class="docstring-binding" href="#SignalIndices.stepsize-Tuple{StepRangeLen}"><code>SignalIndices.stepsize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stepsize(r)</code></pre><p>Return the step size of a range or regularly sampled vector. For a <code>UnitRange</code>, returns <code>1</code>. For a generic vector, returns <code>a[2] - a[1]</code> (assumes regular spacing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1042-L1047">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.subselect-Union{Tuple{T}, Tuple{Any, AbstractVector{&lt;:Tuple{T, T} where T}}, Tuple{Any, AbstractVector{&lt;:Tuple{T, T} where T}, Type{T}}} where T&lt;:(AbstractVector)"><a class="docstring-binding" href="#SignalIndices.subselect-Union{Tuple{T}, Tuple{Any, AbstractVector{&lt;:Tuple{T, T} where T}}, Tuple{Any, AbstractVector{&lt;:Tuple{T, T} where T}, Type{T}}} where T&lt;:(AbstractVector)"><code>SignalIndices.subselect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subselect(base_vec, idx_tup_vec, outtype=...)</code></pre><p>Extract sub-vectors from <code>base_vec</code> using a vector of <code>(start, stop)</code> index tuples. Returns a <code>Vector{outtype}</code> where each element is the slice <code>base_vec[start:stop]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L720-L726">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.t_sup_to_ndx"><a class="docstring-binding" href="#SignalIndices.t_sup_to_ndx"><code>SignalIndices.t_sup_to_ndx</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">t_sup_to_ndx(x, fs, start_t=0, T=Int)</code></pre><p>Convert a time to the index of the last sample strictly before the specified time in a regularly sampled time series. Equivalent to <code>t_to_ndx(...) - 1</code>.</p><p>See also <a href="#SignalIndices.t_to_ndx"><code>t_to_ndx</code></a>, <a href="#SignalIndices.t_to_last_ndx"><code>t_to_last_ndx</code></a>, <a href="#SignalIndices.ndx_to_t"><code>ndx_to_t</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L189-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.t_to_last_ndx"><a class="docstring-binding" href="#SignalIndices.t_to_last_ndx"><code>SignalIndices.t_to_last_ndx</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">t_to_last_ndx(x, fs, start_t=0, T=Int)</code></pre><p>Like <a href="#SignalIndices.t_to_ndx"><code>t_to_ndx</code></a>, but returns the index of the last sample at or before the specified time.</p><p>See also <a href="#SignalIndices.ndx_to_t"><code>ndx_to_t</code></a>, <a href="#SignalIndices.t_sup_to_ndx"><code>t_sup_to_ndx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L170-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.t_to_ndx"><a class="docstring-binding" href="#SignalIndices.t_to_ndx"><code>SignalIndices.t_to_ndx</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">t_to_ndx(x, fs, start_t=0, T=Int)</code></pre><p>Convert a time to its 1-based index in a regularly sampled time series. Returns the index of the first sample at or after the specified time.</p><p>See also <a href="#SignalIndices.ndx_to_t"><code>ndx_to_t</code></a>, <a href="#SignalIndices.t_to_last_ndx"><code>t_to_last_ndx</code></a>, <a href="#SignalIndices.t_sup_to_ndx"><code>t_sup_to_ndx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L147-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.thresh_cross"><a class="docstring-binding" href="#SignalIndices.thresh_cross"><code>SignalIndices.thresh_cross</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">thresh_cross(arr, thresh, comp = &lt;)</code></pre><p>Return indices where <code>arr</code> crosses upward through <code>thresh</code> according to <code>comp</code>. An index <code>i+1</code> is returned when <code>comp(arr[i], thresh)</code> is true and <code>comp(arr[i+1], thresh)</code> is false (i.e., the signal leaves the <code>comp</code> region).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1013-L1019">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.time_interval"><a class="docstring-binding" href="#SignalIndices.time_interval"><code>SignalIndices.time_interval</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">time_interval(npoints, fs, start_t=0)
time_interval(a::AbstractVector, fs, start_t=0)</code></pre><p>Return the <code>(start_t, end_t)</code> time interval of a regularly sampled time series with <code>npoints</code> samples (or a vector <code>a</code>) at sample rate <code>fs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L270-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.trailing_zeros_idx-Tuple{Any}"><a class="docstring-binding" href="#SignalIndices.trailing_zeros_idx-Tuple{Any}"><code>SignalIndices.trailing_zeros_idx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trailing_zeros_idx(arr)</code></pre><p>return last index that is not zero</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L999-L1003">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.uniformhist!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#SignalIndices.uniformhist!-Tuple{Any, Any, Any}"><code>SignalIndices.uniformhist!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">uniformhist!(cnts, xs, r)</code></pre><p>Compute a histogram of <code>xs</code> into pre-allocated count vector <code>cnts</code>, using the bin edges defined by range <code>r</code>. Bins are left-inclusive: a value <code>x</code> falls into bin <code>i</code> when <code>r[i] &lt;= x &lt; r[i+1]</code>.</p><p><code>r</code> must have uniform step size (e.g. a <code>StepRangeLen</code> or <code>UnitRange</code>) and at least 2 elements. The length of <code>cnts</code> must equal <code>length(r) - 1</code>. Values outside the range are silently ignored.</p><p><code>cnts</code> is not zeroed before accumulation, so it must be initialized (e.g. with <code>zeros</code>). This also means <code>uniformhist!</code> can be called repeatedly to accumulate counts from multiple datasets.</p><p>Uses multiplication by the reciprocal of the step size instead of division for a ~20x speedup over naive binning.</p><p>See also <a href="#SignalIndices.uniformhist-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T"><code>uniformhist</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cnts = zeros(Int, 3);

julia&gt; uniformhist!(cnts, [0.1, 0.5, 1.2, 2.9], 0.0:1.0:3.0)
3-element Vector{Int64}:
 2
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1071-L1101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.uniformhist-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T"><a class="docstring-binding" href="#SignalIndices.uniformhist-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T"><code>SignalIndices.uniformhist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">uniformhist([::Type{T} = Int,] xs, r) where T</code></pre><p>Compute a histogram of <code>xs</code> using the bin edges defined by range <code>r</code>, returning a new vector of counts with element type <code>T</code> (default <code>Int</code>). Bins are left-inclusive: a value <code>x</code> falls into bin <code>i</code> when <code>r[i] &lt;= x &lt; r[i+1]</code>.</p><p><code>r</code> must have uniform step size (e.g. a <code>StepRangeLen</code> or <code>UnitRange</code>). The returned vector has length <code>length(r) - 1</code>. Values outside the range are silently ignored.</p><p>See also <a href="#SignalIndices.uniformhist!-Tuple{Any, Any, Any}"><code>uniformhist!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; uniformhist([0.1, 0.5, 1.2, 2.9], 0.0:1.0:3.0)
3-element Vector{Int64}:
 2
 1
 1

julia&gt; uniformhist(Float64, [1, 1, 2, 3, 3, 3], 1:4)
3-element Vector{Float64}:
 2.0
 1.0
 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1107-L1133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.view_trailing_slice-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{&lt;:Any, N}, T}} where {N, T&lt;:Union{Integer, OrdinalRange{&lt;:Integer}}}"><a class="docstring-binding" href="#SignalIndices.view_trailing_slice-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{&lt;:Any, N}, T}} where {N, T&lt;:Union{Integer, OrdinalRange{&lt;:Integer}}}"><code>SignalIndices.view_trailing_slice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">view_trailing_slice(a::AbstractArray{&lt;:Any,N}, idx)</code></pre><p>Return a <code>view</code> of <code>a</code> sliced along its last dimension at <code>idx</code>, with all leading dimensions selected via <code>:</code>. For a 3D array, this is equivalent to <code>view(a, :, :, idx)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L343-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.weighted_mean-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}, T}} where {E&lt;:Number, N, T&lt;:Number}"><a class="docstring-binding" href="#SignalIndices.weighted_mean-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}, T}} where {E&lt;:Number, N, T&lt;:Number}"><code>SignalIndices.weighted_mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weighted_mean(summand, weights, total_weight=sum(weights))</code></pre><p>Compute the weighted mean of <code>summand</code> using element-wise <code>weights</code>. Both arrays must have the same size. Returns a scalar.</p><p>See also <a href="#SignalIndices.weighted_mean_dim-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractVector{T}}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer, T}} where {E&lt;:Number, N, T&lt;:Number}"><code>weighted_mean_dim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L507-L514">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.weighted_mean_dim-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractVector{T}}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer, T}} where {E&lt;:Number, N, T&lt;:Number}"><a class="docstring-binding" href="#SignalIndices.weighted_mean_dim-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractVector{T}}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer}, Tuple{AbstractArray{E, N}, AbstractVector{T}, Integer, T}} where {E&lt;:Number, N, T&lt;:Number}"><code>SignalIndices.weighted_mean_dim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weighted_mean_dim(summand, weights, dim=N, total_weight=sum(weights))</code></pre><p>Compute the weighted mean of <code>summand</code> along dimension <code>dim</code> using <code>weights</code> (a vector whose length matches <code>size(summand, dim)</code>). Returns an array with dimension <code>dim</code> reduced to size 1.</p><p>See also <a href="#SignalIndices.weighted_mean-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}}, Tuple{AbstractArray{E, N}, AbstractArray{T, N}, T}} where {E&lt;:Number, N, T&lt;:Number}"><code>weighted_mean</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L477-L485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.window_counts-NTuple{4, Any}"><a class="docstring-binding" href="#SignalIndices.window_counts-NTuple{4, Any}"><code>SignalIndices.window_counts</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>window_counts</code> in a certain range`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.window_counts-Tuple{Any, Any}"><a class="docstring-binding" href="#SignalIndices.window_counts-Tuple{Any, Any}"><code>SignalIndices.window_counts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">window_counts(ts, window_dur)</code></pre><p>For each event in <code>ts</code>, count the number of events in <code>ts</code> that are in the range of <code>ts[i]</code> and <code>ts[i] + window_dur</code>. Assumes <code>ts</code> is sorted, and that elements of <code>ts</code> are unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/SignalIndices.jl/blob/214bc8d0d82bba36f34e7403f2408c840d9fe1f3/src/SignalIndices.jl#L1219-L1225">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/">« Usage Guide</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 00:07">Tuesday 3 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
